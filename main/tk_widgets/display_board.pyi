import chess
import tkinter as tk
from _typeshed import Incomplete
from chess import Move as Move
from enum import Enum
from typing import Callable

class MoveQuality(Enum):
    BRILLIANT = ...
    GREAT = ...
    BEST = ...
    BOOK = ...
    GOOD = ...
    INACCURACY = ...
    MISTAKE = ...
    BLUNDER = ...
    MISS = ...

class DisplayBoard(tk.Frame):
    UNICODE_PIECES: Incomplete
    master: Incomplete
    board: Incomplete
    border_frame: Incomplete
    canvas: Incomplete
    redo_stack: Incomplete
    animation_fps: Incomplete
    animation_duration: Incomplete
    allow_animation: Incomplete
    auto_stop_animation: Incomplete
    highlighted_move: chess.Move | None
    user_highlights: Incomplete
    system_highlights: Incomplete
    user_circles: Incomplete
    system_circles: Incomplete
    user_arrows: Incomplete
    system_arrows: Incomplete
    board_size: Incomplete
    square_size: Incomplete
    allow_input: Incomplete
    allow_dragging: Incomplete
    allow_drawing: Incomplete
    draw_function: Incomplete
    flipped: Incomplete
    black_bg: Incomplete
    white_bg: Incomplete
    circle_color: Incomplete
    circle_width: Incomplete
    arrow_color: Incomplete
    arrow_width: Incomplete
    highlight_color: Incomplete
    legal_moves_circles_color: Incomplete
    legal_moves_circles_radius: Incomplete
    legal_moves_circles_width: Incomplete
    show_legal: Incomplete
    show_coordinates: Incomplete
    font: Incomplete
    from_color: Incomplete
    to_color: Incomplete
    move_quality_colors: Incomplete
    quality_symbols: Incomplete
    auto_queen_promotion: Incomplete
    def __init__(self, master=None, board_size: int = 480, allow_input: bool = True, allow_dragging: bool = True, allow_drawing: bool = True, black_bg: tuple[int, int, int] = (181, 136, 99), white_bg: tuple[int, int, int] = (240, 217, 181), arrow_color: tuple[int, int, int] = (255, 0, 0), arrow_width: int = 3, circle_color: tuple[int, int, int] = (255, 0, 0), circle_width: int = 3, show_legal: bool = True, legal_moves_circles_color: tuple[int, int, int] = (50, 50, 50), legal_moves_circles_width: int = 5, legal_moves_circles_radius: int = 7, show_coordinates: bool = True, input_callback: Callable | None = None, draw_function: Callable | None = None, flipped: bool = False, highlight_color: tuple[int, int, int] = (150, 232, 125), border: float = 0, border_bg: str | tuple[int, int, int] = '#000', font: str = 'Arial', auto_resize: bool = True, animation_fps: int = 60, animation_duration: float = 0.2, allow_animation: bool = True, auto_stop_animation: bool = False, from_color: str | tuple[int, int, int] = (160, 200, 180), to_color: str | tuple[int, int, int] = (160, 200, 180), move_quality_colors=None, quality_symbols=None, auto_queen_promotion: bool = False, *args, **kwargs) -> None: ...
    @property
    def legal_moves(self): ...
    def piece_at(self, *args, **kwargs): ...
    @property
    def fen(self): ...
    @staticmethod
    def map_pieces_for_animation(from_: chess.Board, to: chess.Board): ...
    @staticmethod
    def rgb_to_hex(col): ...
    @staticmethod
    def row_col_of(square): ...
    def start_animation(self, from_square, to_square, at_end, callback: bool = False, callback_data=None) -> None: ...
    def undo(self): ...
    def redo(self, callback: bool = True): ...
    def clear_redo_stack(self) -> None: ...
    def redraw(self) -> None: ...
    def stop_animation(self) -> None: ...
    def clear_last_move_quality(self) -> None: ...
    def set_move_quality(self, quality: MoveQuality | None): ...
    def clear_user_draw(self, highlights: bool = True, circles: bool = True, arrows: bool = True, last_move: bool = False): ...
    def push(self, move: Move, callback: bool = False) -> None: ...
    def start_move_animation(self, move_: chess.Move, callback: bool = True): ...
    def pop(self) -> Move: ...
    def pop_animation(self) -> chess.Move | None: ...
    def clone_board(self) -> chess.Board: ...
    def make_move(self, from_square, to_square, promo_piece=None, callback: bool = True, animate: bool = True) -> chess.Move | None: ...
    def square_at(self, x: int, y: int) -> chess.Square | None: ...
    def on_move(self, callback: Callable[[chess.Move, DisplayBoard], None]): ...
    def square_center(self, square: chess.Square) -> tuple[int, int]: ...
    def flip_board(self) -> None: ...
    def highlight_square(self, square: chess.Square, color, delete: bool = True, is_user: bool = True): ...
    def highlight_move(self, move: chess.Move): ...
    def draw_circle(self, row: int, col: int, color, radius: int, width: int, delete: bool = True, is_user: bool = True): ...
    def draw_arrow(self, from_row: int, from_col: int, to_row: int, to_col: int, color, width: int, delete: bool = True, is_user: bool = True): ...
    def set_fen(self, fen: str): ...
    def set_fen_with_animation(self, fen: str, callback: Callable = ...): ...
    def generate_svg(self, highlights: bool = True, circles: bool = True, arrows: bool = True, last_move: bool = True, quality: bool = True) -> str: ...
    def export_svg(self, path: str, highlights: bool = True, circles: bool = True, arrows: bool = True, last_move: bool = True, quality: bool = True) -> bool: ...
    def set_readonly(self, value: bool): ...
    def safe_redraw(self): ...
    def set_board(self, board: chess.Board, animate: bool = False, callback=None): ...